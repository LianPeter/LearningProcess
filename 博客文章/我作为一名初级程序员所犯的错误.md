> 以下是我收集到的一些文章


首先我要澄清一点。如果你是一名初级程序员，本文的目的不是让你对你可能犯的错误感到难过，而是让你意识到这些错误，教你如何发现这些错误的迹象，并提醒你避免这些错误。

我过去也犯过这些错误，并从每个错误中吸取了教训。我很高兴养成了编程习惯，这可以帮助我避免犯这些错误。你也应该这样做。

这里列出的这些错误并没有按照特定的顺序排列。

# **1）没有规划地编写代码**

一般来说，高质量的书面内容并不容易创作。它需要仔细思考和研究。高质量的程序也不例外。

编写高质量程序是一个流程化的过程：
**思考**。**研究**。**计划**。**编写**。**验证**。**修改**。
不幸的是，没有好的缩写来表示这一点。你需要养成习惯，始终进行*适当*数量的这些活动。

作为一名初级程序员，我犯过的最大错误之一就是没有经过深思熟虑和研究就立即开始编写代码。虽然这可能适用于小型独立应用程序，但对于大型应用程序来说，它会产生很大的负面影响。

就像你需要在说出任何你可能会后悔的话之前三思而后行一样，你需要在编写任何你可能会后悔的代码之前三思而后行。编码也是一种表达你的想法的方式。

> *生气的时候，先数到10再说话。如果非常生气，就数到100。*
>
> *- 托马斯·杰斐逊。*

以下是我对那句话的解读：

> *检查代码时，在重构一行之前先数到 10。如果代码没有测试，就数到 100。*
>
> *— 萨默·布纳*

编程主要是阅读以前的代码，研究需要什么以及它如何适应当前系统，并以小的、可测试的增量规划功能的编写。实际编写代码行可能只占整个过程的 10%。

不要认为编程就是写一行行代码。编程是一种基于逻辑的创造力，需要培养。

# **2）编写代码前规划太多**

是的。在开始编写代码之前做好计划是件好事，但即使是好事，如果做得太过也会对你造成伤害。喝太多水可能会毒死你。

不要寻找完美的计划。在编程的世界里，这种计划是不存在的。寻找一个足够好的计划，一个你可以用来开始的计划。事实是，你的计划会改变，但它的好处是迫使你进入某种结构，让你的代码更清晰。太多的计划只是浪费你的时间。

我只是在谈论规划小功能。一次性规划所有功能应该被禁止！这就是我们所说的**瀑布方法**，它是一种系统线性规划，具有需要逐一完成的不同步骤。你可以想象这种方法需要多少规划。这不是我在这里谈论的那种规划。瀑布方法不适用于大多数软件项目。任何复杂的事情都只能通过敏捷适应现实来实现。

编写程序必须是一项反应灵敏的活动。您将添加在瀑布计划中从未想过的功能。您将删除一些功能，因为在瀑布计划中从未考虑过的原因。您需要修复错误并适应变化。您需要保持敏捷。

但是，一定要规划好接下来的几个功能。一定要非常小心，因为规划太少和规划太多都会损害代码质量，而代码质量不是你可以冒险的东西。

# **3）低估代码质量的重要性**

如果你只能关注自己编写的代码的一个方面，那应该是它的**可读性**。不清晰的代码是垃圾。它甚至不可回收。

永远不要低估代码质量的重要性。将编码视为一种沟通实现的方式。作为一名程序员，你的主要工作是清楚地传达你正在开发的任何解决方案的实现。

我最喜欢的关于编程的名言之一是：

> *编写代码时一定要假设最终维护你代码的人是一个知道你住在哪里的暴力精神病患者。*
>
> *— 约翰·伍兹*

**非常好的建议，约翰！**

即使是小事也很重要。例如，如果你的缩进和大写不一致，你就会失去编码许可。

```
这比你想象的要更重要！
```

另一个简单的事情是使用长行。超过 80 个字符的任何内容都更难阅读。您可能会想在同一行上放置一些长条件，以使 if 语句块更明显。不要这样做。永远不要超过 80 个字符的限制。

许多类似的简单问题都可以通过**linting**和**格式化**工具轻松解决。在 JavaScript 中，我们有两个可以完美配合的出色工具：**ESLint**和**Prettier**。请帮自己一个忙，始终使用它们。

以下是与代码质量相关的一些错误：

— 在一个函数或文件中使用多行代码。你应该始终将长代码分成可以单独测试和管理的小块。我个人认为任何超过 10 行的函数都太长了，但这只是一个经验法则。

— 使用双重否定。请不要这样做。

> *使用双重否定是非常错误的*

— 使用简短、通用或基于类型的变量名。为变量赋予描述性和非歧义的名称。

> *计算机科学中只有两件难事：缓存失效和命名。——
>
> Phil Karlton*

— 硬编码原始字符串和数字，不提供描述。如果您要编写依赖于固定原始字符串或数字值的逻辑，请将该值放入常量中并为其指定一个好名字。

```
const answerToLifeTheUniverseAndEverything = 42;
```

— 使用草率的捷径和变通方法，避免在简单问题上花费更多时间。不要回避问题。面对现实。

— 认为代码越长越好。在大多数情况下，代码越短越好。只有当代码越长越容易阅读时，才编写更长的代码。例如，不要为了缩短代码而使用巧妙的单行代码和嵌套的三元表达式，也不要故意在不需要时延长代码。删除不必要的代码是您在程序中可以做的最好的事情。

> *用代码行数来衡量编程进度就像用重量来衡量飞机制造进度一样。——
>
> 比尔·盖茨*

— 过度使用条件逻辑。大多数你认为需要条件逻辑的事情都可以在没有条件逻辑的情况下完成。考虑所有替代方案，并仅根据可读性进行选择。除非你可以测量，否则不要优化性能。相关：避免在条件中使用[**Yoda 条件**](https://en.wikipedia.org/wiki/Yoda_conditions) 和赋值。

# **4）选择第一个解决方案**

当我开始编程时，我记得当我遇到问题时，我会找到解决方案并立即付诸实施。我会立即实施，而不会考虑我第一个确定的解决方案的复杂性和潜在的失败。

虽然第一个解决方案可能很诱人，但当你开始质疑你找到的所有解决方案时，通常就会发现好的解决方案。如果你无法想出一个问题的多个解决方案，这可能表明你没有完全理解这个问题。

作为一名专业程序员，你的工作不是找到问题的*解决方案*。而是找到问题**最简单的**解决方案。我说的“简单”是指解决方案必须正确运行、性能良好，但仍然足够简单，易于阅读、理解和维护。

> *构建软件设计有两种方式。一种是让它变得足够简单，以至于显然没有缺陷；另一种是让它变得足够复杂，以至于没有明显的缺陷。*
>
> *— CAR 霍尔*

# **5）不放弃**

我经常犯的另一个错误是，即使我意识到第一个解决方案可能不是最简单的方法，我还是坚持使用它。这可能在心理上与“**不放弃**”的心态有关。在大多数活动中，这是一种很好的心态，但它不应该适用于编程。事实上，在编写程序时，正确的心态是**尽早失败，经常失败**。

当你开始怀疑某个解决方案时，你应该考虑放弃它并重新思考这个问题。无论你对该解决方案投入了多少，这都是正确的。GIT 等源代码控制工具可以帮助你分支并尝试许多不同的解决方案。充分利用这一点。

> *不要因为投入了多少精力而执着于代码。糟糕的代码需要被丢弃。*

# **6）不使用谷歌搜索**

很多时候我都浪费了宝贵的时间来尝试解决一个问题，而我本应该先研究一下它。

除非您使用的是尖端技术，否则当您遇到问题时，很可能其他人也遇到了同样的问题并找到了解决方案。节省一些时间，**先用 Google 搜索一下**。

有时，谷歌搜索会发现你认为的问题其实并非如此，你需要做的不是修复它，而是接受它。不要以为你知道解决问题所需的一切。谷歌会让你大吃一惊。

但是，在谷歌上搜索时要小心谨慎。新手的另一个标志是复制并使用他人的代码而不理解它。虽然该代码可能会正确解决您的问题，但您永远不应该使用任何您不完全理解的代码行。

如果你想成为一名富有创造力的程序员，千万不要认为你知道自己在做什么。

> *作为一个有创造力的人，最危险的想法就是认为你知道自己在做什么。*
>
> *— 布雷特·维克多*

# **7）不使用封装**

这一点与使用面向对象范式无关。使用封装概念总是有用的。不使用封装通常会导致系统更难维护。

在应用程序中，一个功能应该只有一个地方来处理它。这通常是单个对象的责任。该对象应该只显示应用程序中其他对象使用它所绝对必要的内容。这与保密无关，而是关于减少应用程序不同部分之间依赖关系的概念。遵守这些规则可以让您安全地在类、对象和函数的内部进行更改，而不必担心大规模破坏。

逻辑和状态的概念单元应该有自己的**类**。我所说的类是指蓝图模板。这可以是实际的**Class**对象或**Function**对象。您也可以将其标识为**Module**或**Package**。

在逻辑类中，独立的任务部分应该有自己的方法。方法应该做一件事，并做好这件事。类似的类应该使用相同的方法名称。

作为一名初级程序员，我并不总是有为概念单元创建新类的本能，而且我经常无法确定哪些内容可以独立存在。如果您看到一个“ `Util`”类被用作堆放许多不属于同一类的内容的垃圾场，那就是新手代码的标志。如果您进行了简单的更改，然后发现更改会产生连锁效应，并且需要在其他地方进行许多更改，那么这也是新手代码的另一个标志。

在向类添加方法或向方法添加更多职责之前，请思考并质疑您的直觉。您需要时间。不要跳过或认为**稍后会重构**。第一次就做对就好。

这里的主要思想是，您希望您的代码具有**高内聚力**和**低耦合度**，这只是一个花哨的术语，意味着将相关代码放在一起（在一个类中）并减少不同类之间的依赖关系。

# **8）为未知做规划**

人们常常会忍不住去思考自己正在编写的解决方案之外的问题。编写的每一行代码都会让你的脑海中浮现出各种各样的假设。这对于测试极端情况来说是一件好事，但将其用作潜在**需求**的驱动因素则是错误的。

您需要确定您的假设属于哪一类。不要编写您今天不需要的代码。不要为未知的未来做计划。

因为您认为将来可能会需要某个功能而编写该功能是错误的。不要这样做。

始终只编写当前需要的、用于实现解决方案的最少代码。当然，要处理边缘情况，但不要添加*边缘功能*。

> *为了生长而生长是癌细胞的意识形态。*
>
> *— 爱德华·艾比*

# **9）没有使用正确的数据结构**

在准备面试时，初级程序员通常会把过多的注意力放在算法上。识别好的算法并在需要时使用它们是很好的，但记住，它们可能永远不会让你成为编程天才。

然而，记住你可以在你的语言中使用的各种数据结构的优缺点肯定会使你成为一个更好的开发人员。

使用错误的数据结构就像是一块巨大而明亮的广告牌，提醒我们这里有新手代码。

本文的目的并非是教您数据结构，但让我举几个简单的例子：

**— 使用列表（数组）而不是映射（对象）来管理记录**

最常见的数据结构错误可能是使用列表而不是映射来管理记录列表。是的，要管理记录列表，您应该使用映射。

请注意，我在这里谈论的是记录列表，其中每条记录都有一个用于查找该记录的标识符。使用列表来表示标量值是可以的，而且通常是更好的选择，特别是如果使用的重点是将值“推送”到列表。

在JavaScript中，最常见的列表结构是数组，最常见的映射结构是对象（现代JavaScript中也有映射结构）。

使用列表而不是映射来管理记录通常是错误的。虽然这一点实际上只适用于大型集合，但我认为始终坚持这一点。这很重要的主要原因是因为当使用标识符查找记录时，映射比列表快得多。

**不使用堆栈**

在编写需要某种形式的递归的代码时，使用简单的递归函数总是很诱人。然而，优化递归代码通常很困难，尤其是在单线程环境中。

优化递归代码取决于递归函数返回的内容。例如，优化返回两次或多次对自身调用的递归函数比优化仅返回一次对自身调用的递归函数要困难得多。

作为初学者，我们往往会忽略使用递归函数的替代方法。您只需使用*Stack*结构即可。自己将函数调用推送到 Stack，并在准备好遍历调用时开始将其弹出。

# **10）使现有代码变得更糟**

想象一下，你有一间像这样凌乱的房间：

![img](https://miro.medium.com/v2/resize:fit:1400/1*T6gU2PGfqll9h1zT6ApTUA.png)

然后你被要求将一件物品放到那个房间里。由于房间已经很乱了，你可能会想把那件物品放在任何地方。几秒钟后你就可以完成任务了。

不要对混乱的代码这样做。不要让情况变得更糟！始终让代码比刚开始使用时更干净一些。

对上面的房间进行正确的处理是清理需要的东西，以便将新物品放在正确的位置。例如，如果物品是一件需要放在衣柜里的衣服，你需要清理出一条通往衣柜的路。这是正确完成任务的一部分。

下面列出了一些错误的做法，它们通常会使代码变得比原来更混乱（非完整列表）：

- **重复代码**。如果您复制/粘贴代码部分后只更改一行，那么您只是在重复代码并造成更大的混乱。在上述凌乱房间示例中，这就像引入另一把底座较低的椅子，而不是投资购买一把高度可调的新椅子。始终牢记抽象概念并在可能时使用它。
- **不使用配置文件**。如果您需要使用在不同环境或不同时间可能不同的值，则该值属于配置文件。如果您需要在代码中的多个位置使用一个值，则该值属于配置文件。当您向代码引入新值时，请始终问自己这个问题：这个值是否属于配置文件？答案很可能是肯定的。
- **使用不必要的条件语句和临时变量**。每个 if 语句都是一个逻辑分支，需要至少进行双重测试。如果可以避免条件语句而不牺牲可读性，就应该这样做。这样做的主要问题是使用分支逻辑扩展函数，而不是引入另一个函数。每次你认为需要 if 语句或新函数变量时，你都应该问自己：我是否在正确的级别更改代码，还是应该在更高的级别思考问题？

关于不必要的 if 语句，请考虑以下代码：

```
function isOdd(number) { 
  if (number % 2 === 1) {
    return true; 
  } else {
    return false; 
  } 
}
```

上面的函数`isOdd`有几个问题，但你能看出最明显的问题吗？

它使用了不必要的 if 语句。以下是等效的代码：

```
function isOdd(number) { 
  return (number % 2 === 1); 
};
```

# **11）对显而易见的事情发表评论**

我吸取了惨痛的教训，尽量避免写注释。大多数注释都可以用代码中更好命名的元素替换。

例如，代替以下代码：

```
// 此函数仅对数组中的奇数求和
const sum = (val) => { 
  return val.reduce((a, b) => { 
    if (b % 2 === 1) { // 如果当前数字为奇数
      a+=b;             // 将当前数字添加到累加器
    }
    return a;           //累加器
  }, 0); 
};
```

相同的代码可以不加注释地编写，如下所示：

```
const sumOddValues = ( array ) => { 
  return array.reduce(( accumulator , currentNumber ) => { 
    if ( isOdd (currentNumber)) { 
      return accumulator + currentNumber; 
    }    
    return accumulator；
  }，0）；
}；
```

只需为函数和参数使用更好的名称，大多数注释就变得没有必要。在写任何注释之前，请记住这一点。

然而，有时你不得不面对这样的情况：你只能通过注释来使代码更加清晰。这时你应该组织你的注释来回答*“为什么”这个*问题，而不是“*这段代码在做什么”*。

如果您强烈想要写一个 WHAT 注释来澄清代码，请不要指出显而易见的内容。以下是一些无用注释的示例，它们只会给代码增加噪音：

```
// 创建一个变量并将其初始化为 0
 let sum = 0;// 循环遍历数组
array.forEach( 
  // 对于数组中的每个数字
  (number) => { 
    // 将当前数字添加到 sum 变量
    sum += number; 
  } 
);
```

不要成为那样的程序员。不要接受那种代码。如果必须处理这样的注释，请删除它们。最重要的是，教育写出此类注释的程序员，让他们知道这些注释有多糟糕。如果你碰巧雇佣了写出上述注释的程序员，请让他们知道，他们可能会因此丢掉工作。是的……情况就是这么糟糕。

# **12）不写测试**

我将把这一点说得简单一点。如果你认为自己是一名专业程序员，并且这种想法让你有信心在不进行测试的情况下编写代码，那么在我看来，你就是新手。

如果您没有在代码中编写测试，则您很可能以其他方式手动测试程序。如果您正在构建 Web 应用程序，则每写几行代码后您就会刷新并与应用程序交互。我也这样做。手动测试代码没有错。但是，您应该手动测试代码以找出如何自动测试它。如果您成功测试了与应用程序的交互，则应该返回代码编辑器并编写代码，以便在下次向项目添加更多代码时自动执行完全相同的交互。

你是人。每次更改代码后，你都会忘记测试所有之前成功的验证。让计算机替你做这件事吧！

如果可以，在编写代码满足验证要求之前，先猜测或设计验证。测试驱动开发 (TDD) 并非只是一些花哨的炒作。它会积极影响您对功能的看法以及如何为它们提出更好的设计。

TDD 并不适合所有人，也并不适用于每个项目，但如果你可以利用它（哪怕只是部分），你就应该完全这样做。

# **13）假设如果事情进展顺利，那么一切就正确**

看一下实现该`sumOddValues`功能的这个函数。它有什么问题吗？

```
const sumOddValues = (array) => { 
  return array.reduce((accumulator, currentNumber) => { 
    if (currentNumber % 2 === 1) { 
      return accumulator + currentNumber; 
    }   
    return accumulator; 
  }); 
}; 
 
 
console.assert( 
  sumOddValues([1, 2, 3, 4, 5]) === 9 
);
```

断言通过了。生活很美好。对吧，对吧？

上述代码的问题在于它并不完整。它正确处理了几种情况（使用的断言恰好是其中一种情况），但除此之外还有很多问题。让我来列举其中的几个：

**— 问题 1：**没有处理空输入。当函数在没有任何参数的情况下被调用时会发生什么？现在，当发生这种情况时，您会收到一个显示函数实现的错误：

```
类型错误：无法读取未定义的属性“reduce”。
```

![img](https://miro.medium.com/v2/resize:fit:1400/1*DBFKfU-dhTK7xrTI8Ye-iQ.png)

这通常是糟糕代码的标志，主要有两个原因。

- 您的功能的用户不应该遇到有关它的实现细节。
- 错误对用户没有帮助。你的函数对他们来说就是不起作用。但是，如果错误更清楚地说明了使用问题，他们就会知道他们错误地使用了该函数。例如，你可以选择让函数抛出一个用户定义的异常，如下所示：

```
类型错误：无法对空列表执行函数。
```

也许你不需要抛出错误，而是需要设计你的函数来忽略空输入并返回总和`0`。无论如何，必须针对这种情况采取一些措施。

**— 问题 #2：**没有处理无效输入。如果使用字符串、整数或对象值而不是数组来调用该函数，会发生什么情况？

以下是该函数现在将抛出的内容：

```
奇数总和（42）；类型错误：array.reduce 不是一个函数
```

嗯，这很不幸，因为`array.reduce`这绝对是一个功能！

由于我们将函数的参数命名为`array`，因此调用该函数时使用的任何内容（`42`在上面的示例中）都标记为`array`在函数内。错误基本上表明这`42.reduce`不是一个函数。

你看这个错误有多让人困惑，对吧？也许更有帮助的错误应该是：

```
TypeError：42 不是一个数组，老兄。
```

问题 1 和问题 2 有时被称为边缘情况。这些是一些需要规划的常见边缘情况，但通常还有一些不太明显的边缘情况也需要考虑。例如，如果我们使用负数会发生什么？

```
sumOddValues([1, 2, 3, 4, 5, -13]) // => 仍然为 9
```

嗯，`-13`是一个奇数。这是你希望这个函数具有的行为吗？它应该抛出错误吗？它应该在总和中包含负数吗？还是应该像现在这样简单地忽略负数？也许你会意识到这个函数应该被命名为`sumPositiveOddNumbers`。

在这种情况下做出决定很容易。更重要的是，如果你不编写测试用例来记录你的决定，那么你函数的未来维护者将不知道你忽略负数是故意的还是有缺陷的。

> 这不是一个错误，而是一个功能。
>
> — 忘记测试用例的人

**— 问题 3：**并非所有有效情况都经过测试。忘记边缘情况吧，此函数有一个合法且非常简单的情况，但它无法正确处理：

```
sumOddValues([2, 1, 3, 4, 5]) // => 11
```

上述内容`2`被计入总额中，但实际上不应该如此。

解决方案很简单，`reduce`接受第二个参数作为 的初始值`accumulator`。如果没有提供该参数（如上面的代码），`reduce`则只会使用集合中的*第一个*值作为 的初始值`accumulator`。这就是为什么上面的测试用例中的第一个偶数值被包含在总和中的原因。

虽然您可能立即发现了这个问题，或者在编写代码时就发现了这个问题，但是揭示这个问题的测试用例首先应该包含在测试中，以及许多其他测试用例，如全偶数、其中包含的列表`0`和空列表。

如果您看到最少的测试不能处理许多情况或忽略边缘情况，那么这是新手代码的另一个标志。

# **14）不质疑现有代码**

除非你是一位总是独自工作的超级程序员，否则你一生中肯定会遇到一些愚蠢的代码。初学者不会意识到这一点，他们通常会认为这是好代码，因为它似乎可以工作，而且它已经成为代码库的一部分很长时间了。

更糟糕的是，如果错误的代码使用了错误的做法，初学者可能会倾向于在代码库的其他地方重复这种错误的实践，因为他们是从他们认为的好代码中学到了这种做法。

有些代码看起来很糟糕，但可能存在特殊情况，迫使开发人员这样编写代码。这里是提供详细注释的好地方，可以让初学者了解该情况以及代码为何这样编写。

作为初学者，你应该假设任何你不理解的未记录代码都是不好的。质疑它。询问它。`git blame`它！

如果代码作者早已离世或记不清了，请研究该代码并尝试了解其所有内容。只有完全理解代码后，您才能形成好坏判断。在此之前不要假设任何事情。

# **15）关注最佳实践**

我认为“最佳实践”一词实际上是有害的。它暗示不需要进一步研究。这是有史以来最好的做法。不要质疑它！

没有最佳实践。*目前*可能存在适用于此*编程语言的**良好*实践。

我们以前认为的编程最佳实践如今却被称为不良实践。

只要投入足够的时间，你总能找到更好的做法。不要再担心最佳实践，专注于你最擅长的事情。

不要因为你在某处读到的引言、看到别人这样做或有人说这是最佳做法而去做某事。这包括我在本文中给出的所有建议！质疑一切，挑战所有理论，了解所有选择，只做出明智的决定。

# **16）过分关注绩效**

> *过早优化是编程中所有罪恶的根源（或至少是大部分罪恶的根源）*
>
> *— 唐纳德·克努斯（Donald Knuth，1974）*

虽然自从 Donald Knuth 写下上述声明以来，编程已经发生了重大变化，但我认为它今天仍然具有宝贵的建议。

关于这一点要记住的一条好规则是：如果您无法衡量代码的疑似性能问题，就不要尝试优化它。

如果你在执行代码之前进行优化，那么很有可能你做得过早了。你投入时间进行的优化也很有可能是完全没有必要的。

当然，在引入新代码之前，您应该始终考虑一些明显的优化。例如，在 Node.js 中，不要淹没事件循环或阻止调用堆栈非常重要。这是一个您应该始终牢记的早期优化示例。问问自己：我正在考虑的代码会阻止调用堆栈吗？

任何未经测量就对现有代码进行的非明显优化都被视为有害行为，应避免。您认为可以提高性能的行为，如果实施了，可能会成为新的、意想不到的错误之源。

不要浪费时间优化未测量的性能问题。

# **17）不以终端用户体验为目标**

向应用程序添加功能的最简单方法是什么？从您自己的角度来看，或者它如何适应当前的用户界面。对吗？如果该功能是捕获来自用户的某种输入，那么将其附加到您已有的表单中。如果该功能是向页面添加链接，那么将其添加到您已有的嵌套链接菜单中。

**不要成为那样的开发人员。**要成为站在最终用户的角度考虑问题的专业人士。他们会想象这个特定功能的用户需要什么以及他们可能会如何表现。他们会考虑如何让用户轻松找到和使用这个功能，而不是考虑如何让这个功能以某种方式轻松存在于应用程序中，而不考虑该功能的可发现性和可用性。

# **18）没有选择正确的工具**

每个人都有自己最喜欢的工具列表，用于协助他们进行与编程相关的活动。有些工具很好，有些工具很糟糕，但大多数工具只适用于某一特定用途，而对其他用途则不太适用。

锤子是将钉子钉入墙壁的好工具，但用它拧螺丝却是最糟糕的工具。不要仅仅因为您“喜欢”锤子就用它拧螺丝。不要仅仅因为这是亚马逊上最受欢迎的锤子（有 5.0 条用户评论）就用它拧螺丝。

依赖工具的流行度而不是其与问题的契合程度是真正的新手的标志。

关于这一点的一个问题是，您可能不知道对于某项工作来说“更好”的工具。在您目前的知识范围内，某个工具可能是您知道的最好的工具。但是，与其他选项相比，它不会进入榜首。您需要熟悉可用的工具，并对可以开始使用的新工具保持开放的心态。

有些程序员拒绝使用新工具。他们对现有的工具很满意，可能不想学习任何新工具。我理解这一点，我也能理解，但这完全是错误的。

你可以用原始工具慢慢地建造房屋，也可以投入一些时间和金钱购买优质工具，以更快的速度建造更好的房屋。工具在不断改进，你需要熟悉和使用它们。

# **19）不了解代码问题会导致数据问题**

程序的一个重要方面通常是管理某种形式的数据。程序将成为添加新记录、删除旧记录和修改其他记录的界面。

程序代码中哪怕是最小的错误都会导致其管理的数据处于不可预测的状态。如果所有数据验证都完全通过同一个有缺陷的程序进行，情况尤其如此。

初学者可能不会立即理解代码与数据之间的关系。他们可能觉得继续在生产中使用一些有缺陷的代码没什么问题，因为无法正常工作的功能 X 并不重要。问题是，有缺陷的代码可能会不断引入最初并不明显的数据完整性问题。

更糟糕的是，发布修复了错误的代码却没有修复由这些错误引起的细微数据问题，只会积累更多的数据问题，使案例陷入“不可恢复级别”的标签。

如何保护自己免受此类问题的困扰？您可以简单地使用多层数据完整性验证。不要依赖单一用户界面。在前端、后端、网络通信和数据库上创建验证。如果这不是一个选择，那么您至少必须使用数据库级约束。

熟悉数据库约束，并在向数据库添加列和表时使用所有约束：

- **列上的NOT NULL**约束意味着该列将拒绝空值。如果您的应用程序假定该字段存在值，则应在数据库中将其源定义为非空。
- **列上的UNIQUE**约束意味着该列在整个表中不能有重复的值。例如，这对于 Users 表上的用户名或电子邮件字段非常有用。
- CHECK约束是一种自定义表达式，其计算结果必须为真，数据才能被接受。例如，如果您有一个普通百分比列，其**值**必须介于 0 到 100 之间，则可以使用检查约束来强制执行该操作。
- PRIMARY **KEY**约束意味着列的值既非空又唯一。您可能正在使用这个。数据库中的每个表都应该有一个主键来标识其记录。
- FOREIGN **KEY**约束意味着列的值必须与另一个表列中的值匹配，该列通常是主键。

另一个与数据完整性相关的新手问题是缺乏对事务的思考。如果多个操作需要更改同一数据源并且它们相互依赖，则必须将它们包装在一个事务中，以便在其中一个操作失败时可以回滚。

# **20）重新发明轮子**

这是个棘手的问题。在编程中，有些轮子确实值得重新发明。编程不是一个定义明确的领域。很多事情变化得如此之快，新需求的出现速度快得任何团队都无法应对。

例如，如果你需要一个根据一天中的时间以不同速度旋转的轮子，那么我们可能需要重新考虑它，而不是定制我们熟知和喜爱的轮子。但是，除非你真的需要一个在其典型设计中未使用的轮子，否则不要重新发明它。只需使用该死的轮子即可。

有时，在众多可用选项中挑选所需轮子的品牌很有挑战性。购买前先做一些研究并试用！软件“轮子”的妙处在于，它们大多数都是免费且开放的，您可以看到它们的内部设计。您可以通过其内部设计质量轻松判断编码轮子。如果可以，请使用开源轮子。开源软件包可以轻松调试和修复。它们也可以轻松更换。此外，在内部支持它们也更容易。

但是，如果你需要一个轮子，不要买一辆全新的汽车，然后把你正在维护的汽车放在那辆新车上面。不要只为了使用其中的一两个函数而包含整个库。关于这一点最好的例子是JavaScript 中的**lodash**库。如果你只需要对数组进行随机排序，只需导入该`shuffle`方法即可。不要导入整个该死的 lodash 库。

# **21）对代码审查的态度错误**

编程新手的一个特征是他们经常将代码审查视为批评。他们不喜欢代码审查。他们不欣赏代码审查。他们甚至害怕代码审查。

这完全是错误的。如果你有这种感觉，你需要立即改变这种态度。把每一次代码审查都看作是一个学习机会。欢迎他们并欣赏他们。向他们学习。最重要的是，当你的审查者教你一些东西时，要感谢他们。

你永远都是一个代码学习者。你必须接受这一点。大多数代码审查都会教你一些你不知道的东西。把它们归类为学习资源。

有时，审阅者会犯错，这时轮到你教他们一些东西了。但是，如果从你的代码中看不出这一点，那么在这种情况下，你的代码可能需要修改。如果你无论如何都需要教你的审阅者一些东西，那么要知道，教学是你作为程序员可以做的最有意义的活动之一。

# **22）不使用源代码管理**

新手有时会低估一个好的源代码/版本控制系统的力量，我所说的好的系统是指**Git**。

源代码控制不仅仅是将您的更改推送给其他人，供他们使用和构建。它的意义远不止于此。源代码控制是关于清晰的历史记录。代码会受到质疑，而该代码的进展历史将有助于回答一些棘手的问题。这就是我们关心提交消息的原因。它们是传达您的实现的另一个渠道，将它们与小提交一起使用，可以帮助您代码的未来维护者弄清楚代码是如何达到现在的状态的。

经常提交并尽早提交，出于一致性的考虑，请在提交主题行中使用现在时态动词。请详细说明您的消息，但请记住它们应该是摘要。如果您需要在其中写几行以上，那可能表明您的提交太长了。重新定基！

不要在提交信息中包含任何不必要的内容。例如，不要在提交摘要中列出已添加、修改或删除的文件。该列表存在于提交对象本身中，并且可以通过一些 Git 命令参数轻松显示。它只会在摘要信息中产生噪音。有些团队喜欢对每个更改的文件使用不同的摘要，我认为这是提交过大的另一个迹象。

源代码控制也与可发现性有关。如果您遇到一个函数并开始质疑它的必要性或设计，您可以找到引入它的提交并查看该函数的上下文。提交甚至可以帮助您识别哪些代码在程序中引入了错误。Git 甚至在提交中提供二进制搜索（命令`bisect`）来查找引入错误的单个错误提交。

即使在更改正式提交之前，源代码控制也可以以奇妙的方式得到利用。暂存更改、选择性修补、重置、存储、修改、应用、差异、反转等功能的使用为您的编码流程增添了一些丰富的工具。理解它们、学习它们、使用它们并欣赏它们。

在我看来，你知道的 Git 功能越少，你就越是新手。

# **23）过度使用共享状态**

再次强调，这不是函数式编程与其他范式的比较。那是另一篇文章的主题。

这只是因为共享状态是问题的根源，应尽可能避免。如果不可能，应将共享状态的使用保持在最低限度。

作为一名初级程序员，我没有意识到我们定义的每个变量都代表一种共享状态。它保存的数据可以被与该变量处于同一作用域内的所有元素更改。作用域越全局，这种共享状态的跨度就越差。尽量将新状态包含在较小的作用域内，并确保它们不会向上泄漏。

当多个资源需要在同一个事件循环中（在基于事件循环的环境中）一起更改状态时，共享状态的大问题就开始出现。竞争条件将会发生。

问题是：新手可能会倾向于使用计时器作为解决共享状态竞争条件问题的变通方法，尤其是当他们必须处理数据锁定问题时。这是一个很大的危险信号。不要这样做。注意它，在代码审查中指出它，并且永远不要接受它。

# **24）对错误的态度**

错误是好事。这意味着你正在取得进步。这意味着你可以轻松进行后续更改以取得更多进展。

资深程序员喜欢错误，而新手则讨厌错误。

如果看到这些奇妙的小红色错误信息让您感到困扰，您需要改变这种态度。您需要将它们视为帮助者。您需要处理它们。您需要利用它们来取得进展。

有些错误需要升级为异常。异常是用户定义的错误，需要提前计划。有些错误需要置之不理。它们需要让应用程序崩溃并退出。

# **25）不休息**

你是人，你的大脑需要休息。你的身体也需要休息。你经常会处于专注状态而忘记休息。我认为这是新手的另一个标志。这不是你可以妥协的事情。在你的工作流程中整合一些东西来强迫你休息。多休息一会儿。离开你的椅子，散散步，利用这段时间思考下一步该做什么。以全新的眼光重新开始写代码。